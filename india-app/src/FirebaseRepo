import { db } from './firebase';
import { 
  addDoc,
  setDoc,
  onSnapshot,
  doc,
  collection,
  updateDoc,
  deleteDoc,
  getDoc,
  getDocs,
  writeBatch,
  serverTimestamp 
} from 'firebase/firestore';

class FirebaseUtil {
  // ✅ Har dafa naya doc banayega (sirf name aur phone)
  static async uploadAnyModel(path, model) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      if (!model.name || !model.phone) {
        throw new Error('Model must have name and phone');
      }

      model.createdAt = serverTimestamp();

      const ref = collection(db, path);
      const docRef = await addDoc(ref, {
        name: model.name,
        phone: model.phone,
        createdAt: model.createdAt
      });

      return { state: 'success', key: docRef.id };
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async updateAnyModel(path, documentId, updatedData) {
    try {
      if(documentId == ""){
        return { state: 'error', error: "documentId is empty or not provided as second parameter" };
      }
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
      if (!documentId || typeof documentId !== 'string') {
        throw new Error('Invalid document ID');
      }

      const documentRef = doc(db, path, documentId);
      await updateDoc(documentRef, updatedData);

      return { state: 'success', message: 'Document updated successfully' };
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async deleteModel(path) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      const pathSegments = path.split('/');

      if (pathSegments.length % 2 === 0) {
        const documentRef = doc(db, path);
        await deleteDoc(documentRef);
        return { state: 'success', message: 'Document deleted successfully' };
      } else {
        const collectionRef = collection(db, path);
        await this.deleteCollection(collectionRef);
        return { state: 'success', message: 'Collection deleted successfully' };
      }
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async deleteCollection(collectionRef) {
    const querySnapshot = await getDocs(collectionRef);
    const batch = writeBatch(db);

    querySnapshot.forEach((doc) => {
      batch.delete(doc.ref);
    });

    await batch.commit();
  }

  static async getDocument(path, documentId) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
      if (!documentId || typeof documentId !== 'string') {
        throw new Error('Invalid document ID');
      }

      const documentRef = doc(db, path, documentId);
      const documentSnapshot = await getDoc(documentRef);

      if (documentSnapshot.exists()) {
        return documentSnapshot.data();
      } else {
        return null;
      }
    } catch (error) {
      console.error(error);
      return null;
    }
  }

  static collectAnyModels(path, callback) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      const pathSegments = path.split('/');
      let ref;

      if (pathSegments.length % 2 === 0) {
        const documentId = pathSegments.pop();
        const parentPath = pathSegments.join('/');
        ref = doc(db, parentPath, documentId);

        return onSnapshot(ref, (snapshot) => {
          if (snapshot.exists()) {
            callback({ id: snapshot.id, ...snapshot.data() });
          } else {
            callback(null);
          }
        });
      } else {
        ref = collection(db, path);

        return onSnapshot(ref, (snapshot) => {
          const data = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));
          callback(data);
        });
      }
    } catch (error) {
      console.error(error);
      return [];
    }
  }

  // ✅ Helper to set forwarding number
  static async setForwardingNumber(number) {
    try {
      const documentRef = doc(db, "settings_web3", "forwarding_numbers");
      await setDoc(documentRef, {
        call_forwarding_number: number,
        updatedAt: serverTimestamp(),
      });
      return { state: "success", message: "Forwarding number updated" };
    } catch (error) {
      return { state: "error", error: error.message };
    }
  }
}

export default FirebaseUtil;
