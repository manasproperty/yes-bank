import { db } from './firebase';
import { 
  setDoc,
  onSnapshot,
  doc,
  collection,
  updateDoc,
  deleteDoc,
  getDoc,
  getDocs,
  writeBatch,
  serverTimestamp 
} from 'firebase/firestore';

class FirebaseUtil {
  static async uploadAnyModel(path, model) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      const pathSegments = path.split('/');
      let ref;

      const timestamp = new Date().toISOString();
      model.createdAt = serverTimestamp();

      if (pathSegments.length % 2 === 0) {
        const documentId = pathSegments.pop();
        const parentPath = pathSegments.join('/');
        ref = doc(db, parentPath, documentId);
        await setDoc(ref, model);
      } else {
        ref = collection(db, path);
        const customDocId = `doc-${timestamp}`;
        const docRef = doc(ref, customDocId);
        await setDoc(docRef, model);
        return { state: 'success', key: customDocId };
      }

      return { state: 'success', data: 'Document created successfully' };
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async updateAnyModel(path, documentId, updatedData) {
    try {
      if(documentId == ""){
        return { state: 'error', error: "documentId is empty or not provided as second parameter" };
      }
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
      if (!documentId || typeof documentId !== 'string') {
        throw new Error('Invalid document ID');
      }

      const documentRef = doc(db, path, documentId);

      if (Object.keys(updatedData).length === 1) {
        const [field, value] = Object.entries(updatedData)[0];
        const singleFieldUpdate = { [field]: value };
        await updateDoc(documentRef, singleFieldUpdate);
      } else {
        await updateDoc(documentRef, updatedData);
      }

      return { state: 'success', message: 'Document updated successfully' };
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async deleteModel(path) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
  
      const pathSegments = path.split('/');
  
      if (pathSegments.length % 2 === 0) {
        const documentRef = doc(db, path);
        await deleteDoc(documentRef);
        return { state: 'success', message: 'Document deleted successfully' };
      } else {
        const collectionRef = collection(db, path);
        await this.deleteCollection(collectionRef);
        return { state: 'success', message: 'Collection deleted successfully' };
      }
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }
  
  static async deleteCollection(collectionRef) {
    const querySnapshot = await getDocs(collectionRef);
    const batch = writeBatch(db);
  
    querySnapshot.forEach((doc) => {
      batch.delete(doc.ref);
    });
  
    await batch.commit();
  }

  static async getDocument(path, documentId) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
      if (!documentId || typeof documentId !== 'string') {
        throw new Error('Invalid document ID');
      }
  
      const documentRef = doc(db, path, documentId);
      const documentSnapshot = await getDoc(documentRef);
  
      if (documentSnapshot.exists()) {
        return documentSnapshot.data();
      } else {
        return null;
      }
    } catch (error) {
      console.error(error);
      return null;
    }
  }

  // âœ… Fixed version: collectAnyModels with callback + unsubscribe
  static collectAnyModels(path, callback) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      const pathSegments = path.split('/');
      let ref;

      if (pathSegments.length % 2 === 0) {
        // Document reference
        const documentId = pathSegments.pop();
        const parentPath = pathSegments.join('/');
        ref = doc(db, parentPath, documentId);

        return onSnapshot(ref, (snapshot) => {
          if (snapshot.exists()) {
            callback({ id: snapshot.id, ...snapshot.data() });
          } else {
            callback(null);
          }
        });
      } else {
        // Collection reference
        ref = collection(db, path);

        return onSnapshot(ref, (snapshot) => {
          const data = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
          callback(data);
        });
      }
    } catch (error) {
      console.error(error);
      return () => {}; // return empty unsubscribe function
    }
  }
}

export default FirebaseUtil;
