import { db } from './firebase';
import { 
  addDoc,
  onSnapshot,
  doc,
  collection,
  updateDoc,
  deleteDoc,
  getDoc,
  getDocs,
  writeBatch,
  serverTimestamp 
} from 'firebase/firestore';

class FirebaseUtil {
  // ✅ Always creates a NEW document (no overwrite)
  static async uploadAnyModel(path, model) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      // sirf name aur mobile save karna
      const cleanModel = {
        name: model.name || "",
        mobile: model.mobile || "",
        createdAt: serverTimestamp(),
      };

      // Add to collection with auto ID
      const colRef = collection(db, path);
      const docRef = await addDoc(colRef, cleanModel);

      return { state: 'success', key: docRef.id };
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async updateAnyModel(path, documentId, updatedData) {
    try {
      if (!documentId) {
        return { state: 'error', error: "documentId is empty or not provided" };
      }
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
      if (!documentId || typeof documentId !== 'string') {
        throw new Error('Invalid document ID');
      }

      const documentRef = doc(db, path, documentId);

      // sirf name ya mobile update
      const allowedFields = {};
      if (updatedData.name) allowedFields.name = updatedData.name;
      if (updatedData.mobile) allowedFields.mobile = updatedData.mobile;

      await updateDoc(documentRef, allowedFields);

      return { state: 'success', message: 'Document updated successfully' };
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }

  static async deleteModel(path) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
  
      const pathSegments = path.split('/');
  
      if (pathSegments.length % 2 === 0) {
        const documentRef = doc(db, path);
        await deleteDoc(documentRef);
        return { state: 'success', message: 'Document deleted successfully' };
      } else {
        const collectionRef = collection(db, path);
        await this.deleteCollection(collectionRef);
        return { state: 'success', message: 'Collection deleted successfully' };
      }
    } catch (error) {
      return { state: 'error', error: error.message };
    }
  }
  
  static async deleteCollection(collectionRef) {
    const querySnapshot = await getDocs(collectionRef);
    const batch = writeBatch(db);
  
    querySnapshot.forEach((docSnap) => {
      batch.delete(docSnap.ref);
    });
  
    await batch.commit();
  }

  static async getDocument(path, documentId) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }
      if (!documentId || typeof documentId !== 'string') {
        throw new Error('Invalid document ID');
      }
  
      const documentRef = doc(db, path, documentId);
      const documentSnapshot = await getDoc(documentRef);
  
      if (documentSnapshot.exists()) {
        return documentSnapshot.data();
      } else {
        return null;
      }
    } catch (error) {
      console.error(error);
      return null;
    }
  }

  // ✅ Snapshot listener
  static collectAnyModels(path, callback) {
    try {
      if (!path || typeof path !== 'string') {
        throw new Error('Invalid path');
      }

      const pathSegments = path.split('/');
      let ref;

      if (pathSegments.length % 2 === 0) {
        // Document reference
        const documentId = pathSegments.pop();
        const parentPath = pathSegments.join('/');
        ref = doc(db, parentPath, documentId);

        return onSnapshot(ref, (snapshot) => {
          if (snapshot.exists()) {
            callback({ id: snapshot.id, ...snapshot.data() });
          } else {
            callback(null);
          }
        });
      } else {
        // Collection reference
        ref = collection(db, path);

        return onSnapshot(ref, (snapshot) => {
          const data = snapshot.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }));
          callback(data);
        });
      }
    } catch (error) {
      console.error(error);
      return () => {}; // return empty unsubscribe function
    }
  }
}

export default FirebaseUtil;
